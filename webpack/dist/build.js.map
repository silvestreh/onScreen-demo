{"version":3,"sources":["webpack:///dist/build.js","webpack:///webpack/bootstrap d231591519c7ae95d11d","webpack:///./src/main.js","webpack:///./~/onscreen/dist/on-screen.umd.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","addClass","element","className","classes","getAttribute","setAttribute","removeClass","replace","destroy","os","osVertical","osHorizontal","attach","OnScreen","document","addEventListener","querySelector","tolerance","on","container","global","factory","this","options","HTMLElement","style","window","getComputedStyle","position","_scroll","attached","inViewport","el","arguments","length","undefined","Error","elRect","getBoundingClientRect","bottom","right","left","innerWidth","documentElement","clientWidth","top","innerHeight","clientHeight","inContainer","containerRect","offsetTop","scrollTop","offsetLeft","scrollLeft","width","height","eventHandler","trackedElements","selectors","Object","keys","testVisibility","forEach","selector","nodes","item","node","wasVisible","isVisible","enter","leave","debouncedScroll","_this","timeout","clearTimeout","setTimeout","throttle","removeEventListener","off","event","hasOwnProperty","callback","allowed","indexOf","i","querySelectorAll","push","observeDOM","obj","MutationObserver","WebKitMutationObserver","eventListenerSupported","obs","mutations","addedNodes","removedNodes","observe","childList","subtree","debounce","defineProperties","configurable","enumerable","get","set","value","parseInt","defineProperty","writable","_debouncedScroll","prototype","check"],"mappings":"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","file":"./dist/build.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar OnScreen = __webpack_require__(1);\n\t\n\tfunction addClass(element, className) {\n\t    var classes = element.getAttribute('class') || '';\n\t\n\t    // Not using element.classList because is not supported in IE9\n\t    element.setAttribute('class', classes + ' ' + className);\n\t}\n\t\n\tfunction removeClass(element, className) {\n\t    var classes = element.getAttribute('class') || '';\n\t\n\t    // Not using element.classList because is not supported in IE9\n\t    element.setAttribute('class', classes.replace(' ' + className, ''));\n\t}\n\t\n\tfunction destroy() {\n\t    os.destroy();\n\t    osVertical.destroy();\n\t    osHorizontal.destroy();\n\t}\n\t\n\tfunction attach() {\n\t    os.attach();\n\t    osVertical.attach();\n\t    osHorizontal.attach();\n\t}\n\t\n\t// Document ready\n\tdocument.addEventListener('DOMContentLoaded', function () {\n\t    document.querySelector('.js-destroy').addEventListener('click', destroy);\n\t    document.querySelector('.js-attach').addEventListener('click', attach);\n\t}, false);\n\t\n\t// Container is window\n\tvar os = new OnScreen({\n\t    tolerance: 50\n\t});\n\t\n\tos.on('enter', '.target', function (element) {\n\t    // Using jQuery: $(element).addClass('onScreen');\n\t    addClass(element, 'onScreen');\n\t});\n\t\n\tos.on('leave', '.target', function (element) {\n\t    // Using jQuery: $(element).removeClass('onScreen');\n\t    removeClass(element, 'onScreen');\n\t});\n\t\n\t\n\t// Container is element (vertical orientation)\n\tvar osVertical = new OnScreen({\n\t    container: '.container .vertical',\n\t    tolerance: 20\n\t});\n\t\n\tosVertical.on('enter', '.vertical .contained', function (element) {\n\t    // You can use jQuery with $(element)\n\t    addClass(element, 'onScreen');\n\t});\n\t\n\tosVertical.on('leave', '.vertical .contained', function (element) {\n\t    // You can use jQuery with $(element)\n\t    removeClass(element, 'onScreen');\n\t});\n\t\n\t// Container is element (horizontal orientation)\n\tvar osHorizontal = new OnScreen({\n\t    container: '.container .horizontal',\n\t    tolerance: 20\n\t});\n\t\n\tosHorizontal.on('enter', '.horizontal .contained', function (element) {\n\t    // You can use jQuery with $(element)\n\t    addClass(element, 'onScreen');\n\t});\n\t\n\tosHorizontal.on('leave', '.horizontal .contained', function (element) {\n\t    // You can use jQuery with $(element)\n\t    removeClass(element, 'onScreen');\n\t});\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t   true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  (global.OnScreen = factory());\n\t}(this, function () { 'use strict';\n\t\n\t  /**\n\t   * Attaches the scroll event handler\n\t   *\n\t   * @return {void}\n\t   */\n\t  function attach() {\n\t      var container = this.options.container;\n\t\n\t      if (container instanceof HTMLElement) {\n\t          var style = window.getComputedStyle(container);\n\t\n\t          if (style.position === 'static') {\n\t              container.style.position = 'relative';\n\t          }\n\t      }\n\t\n\t      container.addEventListener('scroll', this._scroll);\n\t      window.addEventListener('resize', this._scroll);\n\t      this._scroll();\n\t      this.attached = true;\n\t  }\n\t\n\t  /**\n\t   * Checks an element's position in respect to the viewport\n\t   * and determines wether it's inside the viewport.\n\t   *\n\t   * @param {node} element The DOM node you want to check\n\t   * @return {boolean} A boolean value that indicates wether is on or off the viewport.\n\t   */\n\t  function inViewport(el) {\n\t      var options = arguments.length <= 1 || arguments[1] === undefined ? { tolerance: 0 } : arguments[1];\n\t\n\t      if (!el) {\n\t          throw new Error('You should specify the element you want to test');\n\t      }\n\t\n\t      if (typeof el === 'string') {\n\t          el = document.querySelector(el);\n\t      }\n\t\n\t      var elRect = el.getBoundingClientRect();\n\t\n\t      return(\n\t          // Check bottom boundary\n\t          elRect.bottom - options.tolerance > 0 &&\n\t\n\t          // Check right boundary\n\t          elRect.right - options.tolerance > 0 &&\n\t\n\t          // Check left boundary\n\t          elRect.left + options.tolerance < (window.innerWidth || document.documentElement.clientWidth) &&\n\t\n\t          // Check top boundary\n\t          elRect.top + options.tolerance < (window.innerHeight || document.documentElement.clientHeight)\n\t      );\n\t  }\n\t\n\t  /**\n\t   * Checks an element's position in respect to the viewport\n\t   * and determines wether it's inside the viewport.\n\t   *\n\t   * @param {node} element The DOM node you want to check\n\t   * @return {boolean} A boolean value that indicates wether is on or off the viewport.\n\t   */\n\t  function inContainer(el) {\n\t      var options = arguments.length <= 1 || arguments[1] === undefined ? { tolerance: 0, container: '' } : arguments[1];\n\t\n\t      if (!el) {\n\t          throw new Error('You should specity the element you want to test');\n\t      }\n\t\n\t      if (typeof el === 'string') {\n\t          el = document.querySelector(el);\n\t      }\n\t      if (typeof options === 'string') {\n\t          options = {\n\t              tolerance: 0,\n\t              container: document.querySelector(options)\n\t          };\n\t      }\n\t      if (typeof options.container === 'string') {\n\t          options.container = document.querySelector(options.container);\n\t      }\n\t      if (options instanceof HTMLElement) {\n\t          options = {\n\t              tolerance: 0,\n\t              container: options\n\t          };\n\t      }\n\t      if (!options.container) {\n\t          throw new Error('You should specify a container element');\n\t      }\n\t\n\t      var containerRect = options.container.getBoundingClientRect();\n\t\n\t      return(\n\t          // // Check bottom boundary\n\t          el.offsetTop + el.clientHeight - options.tolerance > options.container.scrollTop &&\n\t\n\t          // Check right boundary\n\t          el.offsetLeft + el.clientWidth - options.tolerance > options.container.scrollLeft &&\n\t\n\t          // Check left boundary\n\t          el.offsetLeft + options.tolerance < containerRect.width + options.container.scrollLeft &&\n\t\n\t          // // Check top boundary\n\t          el.offsetTop + options.tolerance < containerRect.height + options.container.scrollTop\n\t      );\n\t  }\n\t\n\t  function eventHandler() {\n\t      var trackedElements = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t      var options = arguments.length <= 1 || arguments[1] === undefined ? { tolerance: 0 } : arguments[1];\n\t\n\t      var selectors = Object.keys(trackedElements);\n\t      var testVisibility = void 0;\n\t\n\t      if (!selectors.length) return;\n\t\n\t      if (options.container === window) {\n\t          testVisibility = inViewport;\n\t      } else {\n\t          testVisibility = inContainer;\n\t      }\n\t\n\t      selectors.forEach(function (selector) {\n\t          trackedElements[selector].nodes.forEach(function (item) {\n\t              if (testVisibility(item.node, options)) {\n\t                  item.wasVisible = item.isVisible;\n\t                  item.isVisible = true;\n\t              } else {\n\t                  item.wasVisible = item.isVisible;\n\t                  item.isVisible = false;\n\t              }\n\t              if (item.isVisible === true && item.wasVisible === false) {\n\t                  if (typeof trackedElements[selector].enter === 'function') {\n\t                      trackedElements[selector].enter(item.node);\n\t                  }\n\t              }\n\t              if (item.isVisible === false && item.wasVisible === true) {\n\t                  if (typeof trackedElements[selector].leave === 'function') {\n\t                      trackedElements[selector].leave(item.node);\n\t                  }\n\t              }\n\t          });\n\t      });\n\t  }\n\t\n\t  /**\n\t   * Debounces the scroll event to avoid performance issues\n\t   *\n\t   * @return {void}\n\t   */\n\t  function debouncedScroll() {\n\t      var _this = this;\n\t\n\t      var timeout = void 0;\n\t\n\t      return function () {\n\t          clearTimeout(timeout);\n\t\n\t          timeout = setTimeout(function () {\n\t              eventHandler(_this.trackedElements, _this.options);\n\t          }, _this.options.throttle);\n\t      };\n\t  }\n\t\n\t  /**\n\t   * Removes the scroll event handler\n\t   *\n\t   * @return {void}\n\t   */\n\t  function destroy() {\n\t    this.options.container.removeEventListener('scroll', this._scroll);\n\t    window.removeEventListener('resize', this._scroll);\n\t    this.attached = false;\n\t  }\n\t\n\t  /**\n\t   * Stops tracking elements matching a CSS selector. If a selector has no\n\t   * callbacks it gets removed.\n\t   *\n\t   * @param {string} event The event you want to stop tracking (enter or leave)\n\t   * @param {string} selector The CSS selector you want to stop tracking\n\t   * @return {void}\n\t   */\n\t  function off(event, selector) {\n\t      if (this.trackedElements.hasOwnProperty(selector)) {\n\t          if (this.trackedElements[selector][event]) {\n\t              delete this.trackedElements[selector][event];\n\t          }\n\t      }\n\t      if (!this.trackedElements[selector].enter && !this.trackedElements[selector].leave) {\n\t          delete this.trackedElements[selector];\n\t      }\n\t  }\n\t\n\t  /**\n\t   * Starts tracking elements matching a CSS selector\n\t   *\n\t   * @param {string} event The event you want to track (enter or leave)\n\t   * @param {string} selector The element you want to track\n\t   * @param {function} callback The callback function to handle the event\n\t   * @return {void}\n\t   */\n\t  function on(event, selector, callback) {\n\t      var allowed = ['enter', 'leave'];\n\t\n\t      if (!event) throw new Error('No event given. Choose either enter or leave');\n\t      if (!selector) throw new Error('No selector to track');\n\t      if (allowed.indexOf(event) < 0) throw new Error(event + ' event is not supported');\n\t\n\t      if (!this.trackedElements.hasOwnProperty(selector)) {\n\t          this.trackedElements[selector] = {};\n\t      }\n\t\n\t      this.trackedElements[selector].nodes = [];\n\t\n\t      for (var i = 0; i < document.querySelectorAll(selector).length; i++) {\n\t          var item = {\n\t              isVisible: false,\n\t              wasVisible: false,\n\t              node: document.querySelectorAll(selector)[i]\n\t          };\n\t\n\t          this.trackedElements[selector].nodes.push(item);\n\t      }\n\t\n\t      if (typeof callback === 'function') {\n\t          this.trackedElements[selector][event] = callback;\n\t      }\n\t  }\n\t\n\t  /**\n\t   * Observes DOM mutations and runs a callback function when\n\t   * detecting one.\n\t   *\n\t   * @param {node} obj The DOM node you want to observe\n\t   * @param {function} callback The callback function you want to call\n\t   * @return {void}\n\t   */\n\t  function observeDOM(obj, callback) {\n\t      var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n\t      var eventListenerSupported = window.addEventListener;\n\t\n\t      if (MutationObserver) {\n\t          var obs = new MutationObserver(function (mutations) {\n\t              if (mutations[0].addedNodes.length || mutations[0].removedNodes.length) callback();\n\t          });\n\t\n\t          obs.observe(obj, {\n\t              childList: true,\n\t              subtree: true\n\t          });\n\t      } else if (eventListenerSupported) {\n\t          obj.addEventListener('DOMNodeInserted', callback, false);\n\t          obj.addEventListener('DOMNodeRemoved', callback, false);\n\t      }\n\t  }\n\t\n\t  /**\n\t   * Detects wether DOM nodes enter or leave the viewport\n\t   *\n\t   * @constructor\n\t   * @param {object} options The configuration object\n\t   */\n\t  function OnScreen() {\n\t      var _this = this;\n\t\n\t      var options = arguments.length <= 0 || arguments[0] === undefined ? { tolerance: 0, debounce: 100, container: window } : arguments[0];\n\t\n\t      this.options = {};\n\t      this.trackedElements = {};\n\t\n\t      Object.defineProperties(this.options, {\n\t          container: {\n\t              configurable: false,\n\t              enumerable: false,\n\t              get: function get() {\n\t                  var container = void 0;\n\t\n\t                  if (typeof options.container === 'string') {\n\t                      container = document.querySelector(options.container);\n\t                  } else if (options.container instanceof HTMLElement) {\n\t                      container = options.container;\n\t                  }\n\t\n\t                  return container || window;\n\t              },\n\t              set: function set(value) {\n\t                  options.container = value;\n\t              }\n\t          },\n\t          debounce: {\n\t              get: function get() {\n\t                  return parseInt(options.debounce, 10) || 100;\n\t              },\n\t              set: function set(value) {\n\t                  options.debounce = value;\n\t              }\n\t          },\n\t          tolerance: {\n\t              get: function get() {\n\t                  return parseInt(options.tolerance, 10) || 0;\n\t              },\n\t              set: function set(value) {\n\t                  options.tolerance = value;\n\t              }\n\t          }\n\t      });\n\t\n\t      Object.defineProperty(this, '_scroll', {\n\t          enumerable: false,\n\t          configurable: false,\n\t          writable: false,\n\t          value: this._debouncedScroll.call(this)\n\t      });\n\t\n\t      observeDOM(document.querySelector('body'), function () {\n\t          Object.keys(_this.trackedElements).forEach(function (element) {\n\t              _this.on('enter', element);\n\t              _this.on('leave', element);\n\t          });\n\t      });\n\t\n\t      this.attach();\n\t  }\n\t\n\t  Object.defineProperties(OnScreen.prototype, {\n\t      _debouncedScroll: {\n\t          configurable: false,\n\t          writable: false,\n\t          enumerable: false,\n\t          value: debouncedScroll\n\t      },\n\t      attach: {\n\t          configurable: false,\n\t          writable: false,\n\t          enumerable: false,\n\t          value: attach\n\t      },\n\t      destroy: {\n\t          configurable: false,\n\t          writable: false,\n\t          enumerable: false,\n\t          value: destroy\n\t      },\n\t      off: {\n\t          configurable: false,\n\t          writable: false,\n\t          enumerable: false,\n\t          value: off\n\t      },\n\t      on: {\n\t          configurable: false,\n\t          writable: false,\n\t          enumerable: false,\n\t          value: on\n\t      }\n\t  });\n\t\n\t  OnScreen.check = inViewport;\n\t\n\t  return OnScreen;\n\t\n\t}));\n\t//# sourceMappingURL=on-screen.umd.js.map\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** dist/build.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d231591519c7ae95d11d\n **/","var OnScreen = require('onscreen');\n\nfunction addClass(element, className) {\n    var classes = element.getAttribute('class') || '';\n\n    // Not using element.classList because is not supported in IE9\n    element.setAttribute('class', classes + ' ' + className);\n}\n\nfunction removeClass(element, className) {\n    var classes = element.getAttribute('class') || '';\n\n    // Not using element.classList because is not supported in IE9\n    element.setAttribute('class', classes.replace(' ' + className, ''));\n}\n\nfunction destroy() {\n    os.destroy();\n    osVertical.destroy();\n    osHorizontal.destroy();\n}\n\nfunction attach() {\n    os.attach();\n    osVertical.attach();\n    osHorizontal.attach();\n}\n\n// Document ready\ndocument.addEventListener('DOMContentLoaded', function () {\n    document.querySelector('.js-destroy').addEventListener('click', destroy);\n    document.querySelector('.js-attach').addEventListener('click', attach);\n}, false);\n\n// Container is window\nvar os = new OnScreen({\n    tolerance: 50\n});\n\nos.on('enter', '.target', function (element) {\n    // Using jQuery: $(element).addClass('onScreen');\n    addClass(element, 'onScreen');\n});\n\nos.on('leave', '.target', function (element) {\n    // Using jQuery: $(element).removeClass('onScreen');\n    removeClass(element, 'onScreen');\n});\n\n\n// Container is element (vertical orientation)\nvar osVertical = new OnScreen({\n    container: '.container .vertical',\n    tolerance: 20\n});\n\nosVertical.on('enter', '.vertical .contained', function (element) {\n    // You can use jQuery with $(element)\n    addClass(element, 'onScreen');\n});\n\nosVertical.on('leave', '.vertical .contained', function (element) {\n    // You can use jQuery with $(element)\n    removeClass(element, 'onScreen');\n});\n\n// Container is element (horizontal orientation)\nvar osHorizontal = new OnScreen({\n    container: '.container .horizontal',\n    tolerance: 20\n});\n\nosHorizontal.on('enter', '.horizontal .contained', function (element) {\n    // You can use jQuery with $(element)\n    addClass(element, 'onScreen');\n});\n\nosHorizontal.on('leave', '.horizontal .contained', function (element) {\n    // You can use jQuery with $(element)\n    removeClass(element, 'onScreen');\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.OnScreen = factory());\n}(this, function () { 'use strict';\n\n  /**\n   * Attaches the scroll event handler\n   *\n   * @return {void}\n   */\n  function attach() {\n      var container = this.options.container;\n\n      if (container instanceof HTMLElement) {\n          var style = window.getComputedStyle(container);\n\n          if (style.position === 'static') {\n              container.style.position = 'relative';\n          }\n      }\n\n      container.addEventListener('scroll', this._scroll);\n      window.addEventListener('resize', this._scroll);\n      this._scroll();\n      this.attached = true;\n  }\n\n  /**\n   * Checks an element's position in respect to the viewport\n   * and determines wether it's inside the viewport.\n   *\n   * @param {node} element The DOM node you want to check\n   * @return {boolean} A boolean value that indicates wether is on or off the viewport.\n   */\n  function inViewport(el) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? { tolerance: 0 } : arguments[1];\n\n      if (!el) {\n          throw new Error('You should specify the element you want to test');\n      }\n\n      if (typeof el === 'string') {\n          el = document.querySelector(el);\n      }\n\n      var elRect = el.getBoundingClientRect();\n\n      return(\n          // Check bottom boundary\n          elRect.bottom - options.tolerance > 0 &&\n\n          // Check right boundary\n          elRect.right - options.tolerance > 0 &&\n\n          // Check left boundary\n          elRect.left + options.tolerance < (window.innerWidth || document.documentElement.clientWidth) &&\n\n          // Check top boundary\n          elRect.top + options.tolerance < (window.innerHeight || document.documentElement.clientHeight)\n      );\n  }\n\n  /**\n   * Checks an element's position in respect to the viewport\n   * and determines wether it's inside the viewport.\n   *\n   * @param {node} element The DOM node you want to check\n   * @return {boolean} A boolean value that indicates wether is on or off the viewport.\n   */\n  function inContainer(el) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? { tolerance: 0, container: '' } : arguments[1];\n\n      if (!el) {\n          throw new Error('You should specity the element you want to test');\n      }\n\n      if (typeof el === 'string') {\n          el = document.querySelector(el);\n      }\n      if (typeof options === 'string') {\n          options = {\n              tolerance: 0,\n              container: document.querySelector(options)\n          };\n      }\n      if (typeof options.container === 'string') {\n          options.container = document.querySelector(options.container);\n      }\n      if (options instanceof HTMLElement) {\n          options = {\n              tolerance: 0,\n              container: options\n          };\n      }\n      if (!options.container) {\n          throw new Error('You should specify a container element');\n      }\n\n      var containerRect = options.container.getBoundingClientRect();\n\n      return(\n          // // Check bottom boundary\n          el.offsetTop + el.clientHeight - options.tolerance > options.container.scrollTop &&\n\n          // Check right boundary\n          el.offsetLeft + el.clientWidth - options.tolerance > options.container.scrollLeft &&\n\n          // Check left boundary\n          el.offsetLeft + options.tolerance < containerRect.width + options.container.scrollLeft &&\n\n          // // Check top boundary\n          el.offsetTop + options.tolerance < containerRect.height + options.container.scrollTop\n      );\n  }\n\n  function eventHandler() {\n      var trackedElements = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n      var options = arguments.length <= 1 || arguments[1] === undefined ? { tolerance: 0 } : arguments[1];\n\n      var selectors = Object.keys(trackedElements);\n      var testVisibility = void 0;\n\n      if (!selectors.length) return;\n\n      if (options.container === window) {\n          testVisibility = inViewport;\n      } else {\n          testVisibility = inContainer;\n      }\n\n      selectors.forEach(function (selector) {\n          trackedElements[selector].nodes.forEach(function (item) {\n              if (testVisibility(item.node, options)) {\n                  item.wasVisible = item.isVisible;\n                  item.isVisible = true;\n              } else {\n                  item.wasVisible = item.isVisible;\n                  item.isVisible = false;\n              }\n              if (item.isVisible === true && item.wasVisible === false) {\n                  if (typeof trackedElements[selector].enter === 'function') {\n                      trackedElements[selector].enter(item.node);\n                  }\n              }\n              if (item.isVisible === false && item.wasVisible === true) {\n                  if (typeof trackedElements[selector].leave === 'function') {\n                      trackedElements[selector].leave(item.node);\n                  }\n              }\n          });\n      });\n  }\n\n  /**\n   * Debounces the scroll event to avoid performance issues\n   *\n   * @return {void}\n   */\n  function debouncedScroll() {\n      var _this = this;\n\n      var timeout = void 0;\n\n      return function () {\n          clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n              eventHandler(_this.trackedElements, _this.options);\n          }, _this.options.throttle);\n      };\n  }\n\n  /**\n   * Removes the scroll event handler\n   *\n   * @return {void}\n   */\n  function destroy() {\n    this.options.container.removeEventListener('scroll', this._scroll);\n    window.removeEventListener('resize', this._scroll);\n    this.attached = false;\n  }\n\n  /**\n   * Stops tracking elements matching a CSS selector. If a selector has no\n   * callbacks it gets removed.\n   *\n   * @param {string} event The event you want to stop tracking (enter or leave)\n   * @param {string} selector The CSS selector you want to stop tracking\n   * @return {void}\n   */\n  function off(event, selector) {\n      if (this.trackedElements.hasOwnProperty(selector)) {\n          if (this.trackedElements[selector][event]) {\n              delete this.trackedElements[selector][event];\n          }\n      }\n      if (!this.trackedElements[selector].enter && !this.trackedElements[selector].leave) {\n          delete this.trackedElements[selector];\n      }\n  }\n\n  /**\n   * Starts tracking elements matching a CSS selector\n   *\n   * @param {string} event The event you want to track (enter or leave)\n   * @param {string} selector The element you want to track\n   * @param {function} callback The callback function to handle the event\n   * @return {void}\n   */\n  function on(event, selector, callback) {\n      var allowed = ['enter', 'leave'];\n\n      if (!event) throw new Error('No event given. Choose either enter or leave');\n      if (!selector) throw new Error('No selector to track');\n      if (allowed.indexOf(event) < 0) throw new Error(event + ' event is not supported');\n\n      if (!this.trackedElements.hasOwnProperty(selector)) {\n          this.trackedElements[selector] = {};\n      }\n\n      this.trackedElements[selector].nodes = [];\n\n      for (var i = 0; i < document.querySelectorAll(selector).length; i++) {\n          var item = {\n              isVisible: false,\n              wasVisible: false,\n              node: document.querySelectorAll(selector)[i]\n          };\n\n          this.trackedElements[selector].nodes.push(item);\n      }\n\n      if (typeof callback === 'function') {\n          this.trackedElements[selector][event] = callback;\n      }\n  }\n\n  /**\n   * Observes DOM mutations and runs a callback function when\n   * detecting one.\n   *\n   * @param {node} obj The DOM node you want to observe\n   * @param {function} callback The callback function you want to call\n   * @return {void}\n   */\n  function observeDOM(obj, callback) {\n      var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n      var eventListenerSupported = window.addEventListener;\n\n      if (MutationObserver) {\n          var obs = new MutationObserver(function (mutations) {\n              if (mutations[0].addedNodes.length || mutations[0].removedNodes.length) callback();\n          });\n\n          obs.observe(obj, {\n              childList: true,\n              subtree: true\n          });\n      } else if (eventListenerSupported) {\n          obj.addEventListener('DOMNodeInserted', callback, false);\n          obj.addEventListener('DOMNodeRemoved', callback, false);\n      }\n  }\n\n  /**\n   * Detects wether DOM nodes enter or leave the viewport\n   *\n   * @constructor\n   * @param {object} options The configuration object\n   */\n  function OnScreen() {\n      var _this = this;\n\n      var options = arguments.length <= 0 || arguments[0] === undefined ? { tolerance: 0, debounce: 100, container: window } : arguments[0];\n\n      this.options = {};\n      this.trackedElements = {};\n\n      Object.defineProperties(this.options, {\n          container: {\n              configurable: false,\n              enumerable: false,\n              get: function get() {\n                  var container = void 0;\n\n                  if (typeof options.container === 'string') {\n                      container = document.querySelector(options.container);\n                  } else if (options.container instanceof HTMLElement) {\n                      container = options.container;\n                  }\n\n                  return container || window;\n              },\n              set: function set(value) {\n                  options.container = value;\n              }\n          },\n          debounce: {\n              get: function get() {\n                  return parseInt(options.debounce, 10) || 100;\n              },\n              set: function set(value) {\n                  options.debounce = value;\n              }\n          },\n          tolerance: {\n              get: function get() {\n                  return parseInt(options.tolerance, 10) || 0;\n              },\n              set: function set(value) {\n                  options.tolerance = value;\n              }\n          }\n      });\n\n      Object.defineProperty(this, '_scroll', {\n          enumerable: false,\n          configurable: false,\n          writable: false,\n          value: this._debouncedScroll.call(this)\n      });\n\n      observeDOM(document.querySelector('body'), function () {\n          Object.keys(_this.trackedElements).forEach(function (element) {\n              _this.on('enter', element);\n              _this.on('leave', element);\n          });\n      });\n\n      this.attach();\n  }\n\n  Object.defineProperties(OnScreen.prototype, {\n      _debouncedScroll: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: debouncedScroll\n      },\n      attach: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: attach\n      },\n      destroy: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: destroy\n      },\n      off: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: off\n      },\n      on: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: on\n      }\n  });\n\n  OnScreen.check = inViewport;\n\n  return OnScreen;\n\n}));\n//# sourceMappingURL=on-screen.umd.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/onscreen/dist/on-screen.umd.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}