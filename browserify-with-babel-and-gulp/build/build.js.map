{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/onscreen/dist/on-screen.umd.js","src/main.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpXA;;;;;;AAEA,SAAS,OAAT,GAAmB;AACf,OAAG,OAAH;AACA,eAAW,OAAX;AACA,iBAAa,OAAb;AACH;;AAED,SAAS,MAAT,GAAkB;AACd,OAAG,MAAH;AACA,eAAW,MAAX;AACA,iBAAa,MAAb;AACH;;;AAGD,SAAS,gBAAT,CAA0B,kBAA1B,EAA8C,YAAM;AAChD,aAAS,aAAT,CAAuB,aAAvB,EAAsC,gBAAtC,CAAuD,OAAvD,EAAgE,OAAhE;AACA,aAAS,aAAT,CAAuB,YAAvB,EAAqC,gBAArC,CAAsD,OAAtD,EAA+D,MAA/D;AACH,CAHD,EAGG,KAHH;;;AAMA,IAAI,KAAK,uBAAa;AAClB,eAAW;AADO,CAAb,CAAT;;AAIA,GAAG,EAAH,CAAM,OAAN,EAAe,SAAf,EAA0B,UAAC,OAAD,EAAa;;AAEnC,YAAQ,SAAR,CAAkB,GAAlB,CAAsB,UAAtB;AACH,CAHD;;AAKA,GAAG,EAAH,CAAM,OAAN,EAAe,SAAf,EAA0B,UAAC,OAAD,EAAa;;AAEnC,YAAQ,SAAR,CAAkB,MAAlB,CAAyB,UAAzB;AACH,CAHD;;;AAOA,IAAI,aAAa,uBAAa;AAC1B,eAAW,sBADe;AAE1B,eAAW;AAFe,CAAb,CAAjB;;AAKA,WAAW,EAAX,CAAc,OAAd,EAAuB,sBAAvB,EAA+C,UAAC,OAAD,EAAa;;AAExD,YAAQ,SAAR,CAAkB,GAAlB,CAAsB,UAAtB;AACH,CAHD;;AAKA,WAAW,EAAX,CAAc,OAAd,EAAuB,sBAAvB,EAA+C,UAAC,OAAD,EAAa;;AAExD,YAAQ,SAAR,CAAkB,MAAlB,CAAyB,UAAzB;AACH,CAHD;;;AAMA,IAAI,eAAe,uBAAa;AAC5B,eAAW,wBADiB;AAE5B,eAAW;AAFiB,CAAb,CAAnB;;AAKA,aAAa,EAAb,CAAgB,OAAhB,EAAyB,wBAAzB,EAAmD,UAAC,OAAD,EAAa;;AAE5D,YAAQ,SAAR,CAAkB,GAAlB,CAAsB,UAAtB;AACH,CAHD;;AAKA,aAAa,EAAb,CAAgB,OAAhB,EAAyB,wBAAzB,EAAmD,UAAC,OAAD,EAAa;;AAE5D,YAAQ,SAAR,CAAkB,MAAlB,CAAyB,UAAzB;AACH,CAHD","file":"build.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.OnScreen = factory());\n}(this, function () { 'use strict';\n\n  /**\n   * Attaches the scroll event handler\n   *\n   * @return {void}\n   */\n  function attach() {\n      var container = this.options.container;\n\n      if (container instanceof HTMLElement) {\n          var style = window.getComputedStyle(container);\n\n          if (style.position === 'static') {\n              container.style.position = 'relative';\n          }\n      }\n\n      container.addEventListener('scroll', this._scroll);\n      window.addEventListener('resize', this._scroll);\n      this._scroll();\n      this.attached = true;\n  }\n\n  /**\n   * Checks an element's position in respect to the viewport\n   * and determines wether it's inside the viewport.\n   *\n   * @param {node} element The DOM node you want to check\n   * @return {boolean} A boolean value that indicates wether is on or off the viewport.\n   */\n  function inViewport(el) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? { tolerance: 0 } : arguments[1];\n\n      if (!el) {\n          throw new Error('You should specify the element you want to test');\n      }\n\n      if (typeof el === 'string') {\n          el = document.querySelector(el);\n      }\n\n      var elRect = el.getBoundingClientRect();\n\n      return(\n          // Check bottom boundary\n          elRect.bottom - options.tolerance > 0 &&\n\n          // Check right boundary\n          elRect.right - options.tolerance > 0 &&\n\n          // Check left boundary\n          elRect.left + options.tolerance < (window.innerWidth || document.documentElement.clientWidth) &&\n\n          // Check top boundary\n          elRect.top + options.tolerance < (window.innerHeight || document.documentElement.clientHeight)\n      );\n  }\n\n  /**\n   * Checks an element's position in respect to the viewport\n   * and determines wether it's inside the viewport.\n   *\n   * @param {node} element The DOM node you want to check\n   * @return {boolean} A boolean value that indicates wether is on or off the viewport.\n   */\n  function inContainer(el) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? { tolerance: 0, container: '' } : arguments[1];\n\n      if (!el) {\n          throw new Error('You should specity the element you want to test');\n      }\n\n      if (typeof el === 'string') {\n          el = document.querySelector(el);\n      }\n      if (typeof options === 'string') {\n          options = {\n              tolerance: 0,\n              container: document.querySelector(options)\n          };\n      }\n      if (typeof options.container === 'string') {\n          options.container = document.querySelector(options.container);\n      }\n      if (options instanceof HTMLElement) {\n          options = {\n              tolerance: 0,\n              container: options\n          };\n      }\n      if (!options.container) {\n          throw new Error('You should specify a container element');\n      }\n\n      var containerRect = options.container.getBoundingClientRect();\n\n      return(\n          // // Check bottom boundary\n          el.offsetTop + el.clientHeight - options.tolerance > options.container.scrollTop &&\n\n          // Check right boundary\n          el.offsetLeft + el.clientWidth - options.tolerance > options.container.scrollLeft &&\n\n          // Check left boundary\n          el.offsetLeft + options.tolerance < containerRect.width + options.container.scrollLeft &&\n\n          // // Check top boundary\n          el.offsetTop + options.tolerance < containerRect.height + options.container.scrollTop\n      );\n  }\n\n  function eventHandler() {\n      var trackedElements = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n      var options = arguments.length <= 1 || arguments[1] === undefined ? { tolerance: 0 } : arguments[1];\n\n      var selectors = Object.keys(trackedElements);\n      var testVisibility = void 0;\n\n      if (!selectors.length) return;\n\n      if (options.container === window) {\n          testVisibility = inViewport;\n      } else {\n          testVisibility = inContainer;\n      }\n\n      selectors.forEach(function (selector) {\n          trackedElements[selector].nodes.forEach(function (item) {\n              if (testVisibility(item.node, options)) {\n                  item.wasVisible = item.isVisible;\n                  item.isVisible = true;\n              } else {\n                  item.wasVisible = item.isVisible;\n                  item.isVisible = false;\n              }\n              if (item.isVisible === true && item.wasVisible === false) {\n                  if (typeof trackedElements[selector].enter === 'function') {\n                      trackedElements[selector].enter(item.node);\n                  }\n              }\n              if (item.isVisible === false && item.wasVisible === true) {\n                  if (typeof trackedElements[selector].leave === 'function') {\n                      trackedElements[selector].leave(item.node);\n                  }\n              }\n          });\n      });\n  }\n\n  /**\n   * Debounces the scroll event to avoid performance issues\n   *\n   * @return {void}\n   */\n  function debouncedScroll() {\n      var _this = this;\n\n      var timeout = void 0;\n\n      return function () {\n          clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n              eventHandler(_this.trackedElements, _this.options);\n          }, _this.options.throttle);\n      };\n  }\n\n  /**\n   * Removes the scroll event handler\n   *\n   * @return {void}\n   */\n  function destroy() {\n    this.options.container.removeEventListener('scroll', this._scroll);\n    window.removeEventListener('resize', this._scroll);\n    this.attached = false;\n  }\n\n  /**\n   * Stops tracking elements matching a CSS selector. If a selector has no\n   * callbacks it gets removed.\n   *\n   * @param {string} event The event you want to stop tracking (enter or leave)\n   * @param {string} selector The CSS selector you want to stop tracking\n   * @return {void}\n   */\n  function off(event, selector) {\n      if (this.trackedElements.hasOwnProperty(selector)) {\n          if (this.trackedElements[selector][event]) {\n              delete this.trackedElements[selector][event];\n          }\n      }\n      if (!this.trackedElements[selector].enter && !this.trackedElements[selector].leave) {\n          delete this.trackedElements[selector];\n      }\n  }\n\n  /**\n   * Starts tracking elements matching a CSS selector\n   *\n   * @param {string} event The event you want to track (enter or leave)\n   * @param {string} selector The element you want to track\n   * @param {function} callback The callback function to handle the event\n   * @return {void}\n   */\n  function on(event, selector, callback) {\n      var allowed = ['enter', 'leave'];\n\n      if (!event) throw new Error('No event given. Choose either enter or leave');\n      if (!selector) throw new Error('No selector to track');\n      if (allowed.indexOf(event) < 0) throw new Error(event + ' event is not supported');\n\n      if (!this.trackedElements.hasOwnProperty(selector)) {\n          this.trackedElements[selector] = {};\n      }\n\n      this.trackedElements[selector].nodes = [];\n\n      for (var i = 0; i < document.querySelectorAll(selector).length; i++) {\n          var item = {\n              isVisible: false,\n              wasVisible: false,\n              node: document.querySelectorAll(selector)[i]\n          };\n\n          this.trackedElements[selector].nodes.push(item);\n      }\n\n      if (typeof callback === 'function') {\n          this.trackedElements[selector][event] = callback;\n      }\n  }\n\n  /**\n   * Observes DOM mutations and runs a callback function when\n   * detecting one.\n   *\n   * @param {node} obj The DOM node you want to observe\n   * @param {function} callback The callback function you want to call\n   * @return {void}\n   */\n  function observeDOM(obj, callback) {\n      var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n      var eventListenerSupported = window.addEventListener;\n\n      if (MutationObserver) {\n          var obs = new MutationObserver(function (mutations) {\n              if (mutations[0].addedNodes.length || mutations[0].removedNodes.length) callback();\n          });\n\n          obs.observe(obj, {\n              childList: true,\n              subtree: true\n          });\n      } else if (eventListenerSupported) {\n          obj.addEventListener('DOMNodeInserted', callback, false);\n          obj.addEventListener('DOMNodeRemoved', callback, false);\n      }\n  }\n\n  /**\n   * Detects wether DOM nodes enter or leave the viewport\n   *\n   * @constructor\n   * @param {object} options The configuration object\n   */\n  function OnScreen() {\n      var _this = this;\n\n      var options = arguments.length <= 0 || arguments[0] === undefined ? { tolerance: 0, debounce: 100, container: window } : arguments[0];\n\n      this.options = {};\n      this.trackedElements = {};\n\n      Object.defineProperties(this.options, {\n          container: {\n              configurable: false,\n              enumerable: false,\n              get: function get() {\n                  var container = void 0;\n\n                  if (typeof options.container === 'string') {\n                      container = document.querySelector(options.container);\n                  } else if (options.container instanceof HTMLElement) {\n                      container = options.container;\n                  }\n\n                  return container || window;\n              },\n              set: function set(value) {\n                  options.container = value;\n              }\n          },\n          debounce: {\n              get: function get() {\n                  return parseInt(options.debounce, 10) || 100;\n              },\n              set: function set(value) {\n                  options.debounce = value;\n              }\n          },\n          tolerance: {\n              get: function get() {\n                  return parseInt(options.tolerance, 10) || 0;\n              },\n              set: function set(value) {\n                  options.tolerance = value;\n              }\n          }\n      });\n\n      Object.defineProperty(this, '_scroll', {\n          enumerable: false,\n          configurable: false,\n          writable: false,\n          value: this._debouncedScroll.call(this)\n      });\n\n      observeDOM(document.querySelector('body'), function () {\n          Object.keys(_this.trackedElements).forEach(function (element) {\n              _this.on('enter', element);\n              _this.on('leave', element);\n          });\n      });\n\n      this.attach();\n  }\n\n  Object.defineProperties(OnScreen.prototype, {\n      _debouncedScroll: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: debouncedScroll\n      },\n      attach: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: attach\n      },\n      destroy: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: destroy\n      },\n      off: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: off\n      },\n      on: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: on\n      }\n  });\n\n  OnScreen.check = inViewport;\n\n  return OnScreen;\n\n}));\n//# sourceMappingURL=on-screen.umd.js.map","import OnScreen from 'onscreen';\n\nfunction destroy() {\n    os.destroy();\n    osVertical.destroy();\n    osHorizontal.destroy();\n}\n\nfunction attach() {\n    os.attach();\n    osVertical.attach();\n    osHorizontal.attach();\n}\n\n// Document ready\ndocument.addEventListener('DOMContentLoaded', () => {\n    document.querySelector('.js-destroy').addEventListener('click', destroy);\n    document.querySelector('.js-attach').addEventListener('click', attach);\n}, false);\n\n// Container is window\nvar os = new OnScreen({\n    tolerance: 50\n});\n\nos.on('enter', '.target', (element) => {\n    // Using jQuery: $(element).addClass('onScreen');\n    element.classList.add('onScreen');\n});\n\nos.on('leave', '.target', (element) => {\n    // Using jQuery: $(element).removeClass('onScreen');\n    element.classList.remove('onScreen');\n});\n\n\n// Container is element (vertical orientation)\nvar osVertical = new OnScreen({\n    container: '.container .vertical',\n    tolerance: 20\n});\n\nosVertical.on('enter', '.vertical .contained', (element) => {\n    // You can use jQuery with $(element)\n    element.classList.add('onScreen');\n});\n\nosVertical.on('leave', '.vertical .contained', (element) => {\n    // You can use jQuery with $(element)\n    element.classList.remove('onScreen');\n});\n\n// Container is element (horizontal orientation)\nvar osHorizontal = new OnScreen({\n    container: '.container .horizontal',\n    tolerance: 20\n});\n\nosHorizontal.on('enter', '.horizontal .contained', (element) => {\n    // You can use jQuery with $(element)\n    element.classList.add('onScreen');\n});\n\nosHorizontal.on('leave', '.horizontal .contained', (element) => {\n    // You can use jQuery with $(element)\n    element.classList.remove('onScreen');\n});\n"]}